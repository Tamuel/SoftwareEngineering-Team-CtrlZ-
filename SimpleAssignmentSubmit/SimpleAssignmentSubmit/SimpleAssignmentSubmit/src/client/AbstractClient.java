// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com package client;import java.io.*;import java.net.*;import java.util.*;/*** The <code> AbstractClient </code> contains all the* methods necessary to set up the client side of a client-server* architecture.  When a client is thus connected to the* server, the two programs can then exchange <code> Object </code>* instances.<p>** 이 Class 는 client-server 에 필요한 아키텍쳐의 모든 필요한 메소드들을 정의한다.* client 가 server에 연결되면 두 프로그램 사이에 Object instance 들을 교환 가능하다.** Method <code> handleMessageFromServer </code> must be defined by* a concrete subclass. Several other hook methods may also be* overriden.<p>** handleMessageFromServer는 무조건 concrete subclass 에 의해 정의되어야 한다.* 다른 메소드들도 오버라이드 가능하다.** Several public service methods are provided to* application that use this framework.<p>** 몇몇 메소드들은 어플리케이션이 프레임워크를 이용하기 위해 제공되어있다.** Project Name: OCSF (Object Client-Server Framework)<p>* *  *   * @author Dr. Robert Lagani&egrave;re* @author Dr. Timothy C. Lethbridge* @author Fran&ccedil;ois  B&eacutel;langer* @author Paul Holden* @version February 2001 (2.12)*/public abstract class AbstractClient implements Runnable{// INSTANCE VARIABLES ***********************************************  /**  * Sockets are used in the operating system as channels  * of communication between two processes.  *   * Socket 들은 OS에서 두 프로세스 간의 의사소통을 위 채널이다.  *   * @see java.net.Socket  */  private Socket clientSocket;  /**  * The stream to handle data going to the server.  * Server로 데이터를 보내기 위한 스트림.  */  private ObjectOutputStream output;  /**  * The stream to handle data from the server.  * Server에서 데이터를 받기 위한 스트림.  */  private ObjectInputStream input;  /**  * The thread created to read data from the server.  * 이 스레드는 서버에서 데이터를 읽기 위해 생성됨.  */  private Thread clientReader;  /**  * Indicates if the thread is ready to stop.  * 스레드가 멈출 준비가 되었을 때 알려  * Needed so that the loop in the run method knows when to stop  * waiting for incoming messages.  *   */  private boolean readyToStop= false;  /**  * The server's host name.  */  private String host;  /**  * The port number.  */  private int port;// CONSTRUCTORS *****************************************************  /**   * Constructs the client.   *   * @param  host  the server's host name.   * @param  port  the port number.   */  public AbstractClient(String host, int port)  {    // Initialize variables    this.host = host;    this.port = port;  }// INSTANCE METHODS *************************************************  /**   * Opens the connection with the server.   * If the connection is already opened, this call has no effect.   *    * 서버와의 connection 을 연다.   * connection 이 이미 열려 있다면, 이 콜은 아무 효과가 없다.   *    * @exception IOException if an I/O error occurs when opening.   */  final public void openConnection() throws IOException  {    // Do not do anything if the connection is already open    if(isConnected())      return;    //Create the sockets and the data streams    try    {      clientSocket= new Socket(host, port);      output = new ObjectOutputStream(clientSocket.getOutputStream());      input = new ObjectInputStream(clientSocket.getInputStream());    }    catch (IOException ex)    // All three of the above must be closed when there is a failure    // to create any of them    {      try      {        closeAll();      }      catch (Exception exc) { }      throw ex; // Rethrow the exception.    }    clientReader = new Thread(this);  //Create the data reader thread    readyToStop = false;    clientReader.start();  //Start the thread  }  /**   * Sends an object to the server. This is the only way that   * methods should communicate with the server.   *   * 객체를 서버로 전송한다.   * 이 메소드는 서버와 통신하기 위한 유일한 경로이다.   *   * @param msg   The message to be sent.   * @exception IOException if an I/O error occurs when sending   */  final public void sendToServer(Object msg) throws IOException  {    if (clientSocket == null || output == null)      throw new SocketException("socket does not exist");    output.writeObject(msg);  }  /**   * Closes the connection to the server.   *   * @exception IOException if an I/O error occurs when closing.   */  final public void closeConnection() throws IOException  {    // Prevent the thread from looping any more    readyToStop= true;    try    {      closeAll();    }    finally    {      // Call the hook method      connectionClosed();    }  }// ACCESSING METHODS ------------------------------------------------  /**   * @return true if the client is connnected.   */  final public boolean isConnected()  {    return clientReader!=null && clientReader.isAlive();  }  /**   * @return the port number.   */  final public int getPort()  {    return port;  }  /**   * Sets the server port number for the next connection.   * The change in port only takes effect at the time of the   * next call to openConnection().   *   * @param port the port number.   */  final public void setPort(int port)  {    this.port = port;  }  /**   * @return the host name.   */  final public String getHost()  {    return host;  }  /**   * Sets the server host for the next connection.   * The change in host only takes effect at the time of the   * next call to openConnection().   *   * @param host the host name.   */  final public void setHost(String host)  {    this.host = host;  }  /**   * returns the client's description.   *   * @return the client's Inet address.   */  final public InetAddress getInetAddress()  {    return clientSocket.getInetAddress();  }// RUN METHOD -------------------------------------------------------  /**   * Waits for messages from the server. When each arrives,   * a call is made to <code>handleMessageFromServer()</code>.   * Not to be explicitly called.   *    * server에서의 메세지를 기다린다.   * 메세지가 오면 handleMessageFromServer를 부른다.   *    */  final public void run()  {    connectionEstablished();    // The message from the server    Object msg;    // Loop waiting for data    try    {      while(!readyToStop)      {        // Get data from Server and send it to the handler        // The thread waits indefinitely at the following        // statement until something is received from the server    	// Sever 에서 어떤 데이터를 받을 때까지 메세지를 읽는다.        msg = input.readObject();        // Concrete subclasses do what they want with the        // msg by implementing the following method        handleMessageFromServer(msg);      }    }    catch (Exception exception)    {      if(!readyToStop)      {        try        {          closeAll();        }        catch (Exception ex) { }        connectionException(exception);      }    }    finally    {      clientReader = null;    }  }// METHODS DESIGNED TO BE OVERRIDDEN BY CONCRETE SUBCLASSES ---------  /**   * Hook method called after the connection has been closed.   * The default implementation does nothing. The method   * may be overriden by subclasses to perform special processing   * such as cleaning up and terminating, or attempting to   * reconnect.   */  protected void connectionClosed() {}  /**   * Hook method called each time an exception is thrown by the   * client's thread that is waiting for messages from the server.   * The method may be overridden by subclasses.   *   * @param exception the exception raised.   */  protected void connectionException(Exception exception) {}  /**   * Hook method called after a connection has been established.   * The default implementation does nothing.   * It may be overridden by subclasses to do anything they wish.   */  protected void connectionEstablished() {}  /**   * Handles a message sent from the server to this client.   * This MUST be implemented by subclasses, who should respond to   * messages.   *   * @param msg   the message sent.   */  protected abstract void handleMessageFromServer(Object msg);// METHODS TO BE USED FROM WITHIN THE FRAMEWORK ONLY ----------------  /**   * Closes all aspects of the connection to the server.   *   * @exception IOException if an I/O error occurs when closing.   */  private void closeAll() throws IOException  {    try    {      //Close the socket      if (clientSocket != null)        clientSocket.close();      //Close the output stream      if (output != null)        output.close();      //Close the input stream      if (input != null)        input.close();    }    finally    {      // Set the streams and the sockets to NULL no matter what      // Doing so allows, but does not require, any finalizers      // of these objects to reclaim system resources if and      // when they are garbage collected.      output = null;      input = null;      clientSocket = null;    }  }}// end of AbstractClient class