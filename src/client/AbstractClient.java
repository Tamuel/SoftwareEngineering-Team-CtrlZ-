// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com package client;import java.io.*;import java.net.*;import java.util.*;import common.ProtocolType;import ServerClientConsole.Protocol;/** * The <code> AbstractClient </code> contains all the methods necessary to set * up the client side of a client-server architecture. When a client is thus * connected to the server, the two programs can then exchange * <code> Object </code> instances. * <p> * * 이 Class 는 client-server 에 필요한 아키텍쳐의 모든 필요한 메소드들을 정의한다. client 가 server에 연결되면 * 두 프로그램 사이에 Object instance 들을 교환 가능하다. * * Method <code> handleMessageFromServer </code> must be defined by a concrete * subclass. Several other hook methods may also be overriden. * <p> * * handleMessageFromServer는 무조건 concrete subclass 에 의해 정의되어야 한다. 다른 메소드들도 오버라이드 * 가능하다. * * Several public service methods are provided to application that use this * framework. * <p> * * 몇몇 메소드들은 어플리케이션이 프레임워크를 이용하기 위해 제공되어있다. * * Project Name: OCSF (Object Client-Server Framework) * <p> *  *  *  * @author Dr. Robert Lagani&egrave;re * @author Dr. Timothy C. Lethbridge * @author Fran&ccedil;ois B&eacutel;langer * @author Paul Holden * @version February 2001 (2.12) */public abstract class AbstractClient implements Runnable {	// INSTANCE VARIABLES ***********************************************	private Boolean msgReceive = false;	/**	 * Sockets are used in the operating system as channels of communication	 * between two processes.	 * 	 * Socket 들은 OS에서 두 프로세스 간의 의사소통을 위 채널이다.	 * 	 * @see java.net.Socket	 */	private Socket clientSocket;	/**	 * The stream to handle data going to the server. Server로 데이터를 보내기 위한 스트림.	 */	private ObjectOutputStream output;	/**	 * The stream to handle data from the server. Server에서 데이터를 받기 위한 스트림.	 */	private ObjectInputStream input;	/**	 * The thread created to read data from the server. 이 스레드는 서버에서 데이터를 읽기 위해	 * 생성됨.	 */	private Thread clientReader;	/**	 * Indicates if the thread is ready to stop. 스레드가 멈출 준비가 되었을 때 알려 Needed so	 * that the loop in the run method knows when to stop waiting for incoming	 * messages.	 * 	 */	private boolean readyToStop = false;	/**	 * The server's host name.	 */	private String host;	/**	 * The port number.	 */	private int port;	// CONSTRUCTORS *****************************************************	/**	 * Constructs the client.	 *	 * @param host	 *            the server's host name.	 * @param port	 *            the port number.	 */	public AbstractClient(String host, int port) {		// Initialize variables		this.host = host;		this.port = port;	}	// INSTANCE METHODS *************************************************	/**	 * Opens the connection with the server. If the connection is already	 * opened, this call has no effect.	 * 	 * 서버와의 connection 을 연다. connection 이 이미 열려 있다면, 이 콜은 아무 효과가 없다.	 * 	 * @exception IOException	 *                if an I/O error occurs when opening.	 */	final public void openConnection() throws IOException {		// Do not do anything if the connection is already open		if (isConnected())			return;		// Create the sockets and the data streams		try {			clientSocket = new Socket(host, port);			output = new ObjectOutputStream(clientSocket.getOutputStream());			input = new ObjectInputStream(clientSocket.getInputStream());		} catch (IOException ex)		// All three of the above must be closed when there is a failure		// to create any of them		{			try {				closeAll();			} catch (Exception exc) {			}			throw ex; // Rethrow the exception.		}		clientReader = new Thread(this); // Create the data reader thread		readyToStop = false;		clientReader.start(); // Start the thread	}	/**	 * Sends an object to the server. This is the only way that methods should	 * communicate with the server.	 *	 * 객체를 서버로 전송한다. 이 메소드는 서버와 통신하기 위한 유일한 경로이다.	 *	 * @param msg	 *            The message to be sent.	 * @exception IOException	 *                if an I/O error occurs when sending	 */	final public void sendToServer(ProtocolType procType, Object data) throws IOException {		if (clientSocket == null || output == null)			throw new SocketException("socket does not exist");		Protocol proc = new Protocol(procType, data);		System.out.println("Send to Server : " + proc.getProcKind() + " " + proc.getData());		output.writeObject(proc);		setMsgReceive(false);	}	/**	 * Closes the connection to the server.	 *	 * @exception IOException	 *                if an I/O error occurs when closing.	 */	final public void closeConnection() throws IOException {		// Prevent the thread from looping any more		readyToStop = true;		try {			closeAll();		} finally {			// Call the hook method			connectionClosed();		}	}	// ACCESSING METHODS ------------------------------------------------	/**	 * @return true if the client is connnected.	 */	final public boolean isConnected() {		return clientReader != null && clientReader.isAlive();	}	/**	 * @return the port number.	 */	final public int getPort() {		return port;	}	/**	 * Sets the server port number for the next connection. The change in port	 * only takes effect at the time of the next call to openConnection().	 *	 * @param port	 *            the port number.	 */	final public void setPort(int port) {		this.port = port;	}	/**	 * @return the host name.	 */	final public String getHost() {		return host;	}	/**	 * Sets the server host for the next connection. The change in host only	 * takes effect at the time of the next call to openConnection().	 *	 * @param host	 *            the host name.	 */	final public void setHost(String host) {		this.host = host;	}	/**	 * returns the client's description.	 *	 * @return the client's Inet address.	 */	final public InetAddress getInetAddress() {		return clientSocket.getInetAddress();	}	// RUN METHOD -------------------------------------------------------	/**	 * Waits for messages from the server. When each arrives, a call is made to	 * <code>handleMessageFromServer()</code>. Not to be explicitly called.	 * 	 * server에서의 메세지를 기다린다. 메세지가 오면 handleMessageFromServer를 부른다.	 * 	 */	final public void run() {		connectionEstablished();		// The message from the server		Object msg;		// Loop waiting for data		try {			while (!readyToStop) {				// Get data from Server and send it to the handler				// The thread waits indefinitely at the following				// statement until something is received from the server				// Sever 에서 어떤 데이터를 받을 때까지 메세지를 읽는다.				msg = input.readObject();				// Concrete subclasses do what they want with the				// msg by implementing the following method				handleMessageFromServer(msg);			}		} catch (Exception exception) {			if (!readyToStop) {				try {					closeAll();				} catch (Exception ex) {				}				connectionException(exception);			}		} finally {			clientReader = null;		}	}	// METHODS DESIGNED TO BE OVERRIDDEN BY CONCRETE SUBCLASSES ---------	/**	 * Hook method called after the connection has been closed. The default	 * implementation does nothing. The method may be overriden by subclasses to	 * perform special processing such as cleaning up and terminating, or	 * attempting to reconnect.	 */	protected void connectionClosed() {	}	/**	 * Hook method called each time an exception is thrown by the client's	 * thread that is waiting for messages from the server. The method may be	 * overridden by subclasses.	 *	 * @param exception	 *            the exception raised.	 */	protected void connectionException(Exception exception) {	}	/**	 * Hook method called after a connection has been established. The default	 * implementation does nothing. It may be overridden by subclasses to do	 * anything they wish.	 */	protected void connectionEstablished() {	}	/**	 * Handles a message sent from the server to this client. This MUST be	 * implemented by subclasses, who should respond to messages.	 *	 * @param msg	 *            the message sent.	 */	protected abstract void handleMessageFromServer(Object msg);	// METHODS TO BE USED FROM WITHIN THE FRAMEWORK ONLY ----------------	public Boolean isMsgReceive() {		return msgReceive;	}	public void setMsgReceive(Boolean msgReceive) {		this.msgReceive = msgReceive;	}	/**	 * Closes all aspects of the connection to the server.	 *	 * @exception IOException	 *                if an I/O error occurs when closing.	 */	private void closeAll() throws IOException {		try {			// Close the socket			if (clientSocket != null)				clientSocket.close();			// Close the output stream			if (output != null)				output.close();			// Close the input stream			if (input != null)				input.close();		} finally {			// Set the streams and the sockets to NULL no matter what			// Doing so allows, but does not require, any finalizers			// of these objects to reclaim system resources if and			// when they are garbage collected.			output = null;			input = null;			clientSocket = null;		}	}}// end of AbstractClient class